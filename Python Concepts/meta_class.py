"""
The metaclass is responsible for the generation of classes, 
so we can write our custom metaclasses to modify the way classes are generated by 
performing extra actions or injecting code. Usually, we do not need custom metaclasses 
but sometimes itâ€™s necessary. 
There are problems for which metaclass and non-metaclass-based solutions 
are available (which are often simpler) but in some cases, 
only metaclass can solve the problem. We will discuss such a problem in this article.
"""



class BaseProfile:
    x = 5


if __name__ == '__main__':
    Profile = type(
        "Profile",
        (BaseProfile,),
        {
            "name": "Parvez",
            "age": 29,
            "job": "Software Engineer",
            "__str__": lambda self: f"{self.name} {self.job} {self.age}"
        },
    )

    profile = Profile()
    print(profile)
    print(profile.x)
